## Author: Patrick Chang
# Script file for the MM Complex Fourier Transform
# Supporting Algorithms are at the start of the script
#  Include:
#           - Scale function to re-scale time to [0, 2 \pi]
# Number of Fourier Coefficients automatically chosen so that events
# are not aliased

#---------------------------------------------------------------------------

### Data Format:
## p = [n x 2] matrix of prices, log returns are computed in the function
# non-trading times are indicated by NaNs
## t = [n x 2] matrix of trading times, non-trading times are indicated by NaNs
# dimensions of p and t must match.

#---------------------------------------------------------------------------

using ArgCheck
using LinearAlgebra

#---------------------------------------------------------------------------
### Supporting functions

function scale(t)
    maxt = maximum(filter(!isnan, t))
    mint = minimum(filter(!isnan, t))

    tau = (2*pi) .* (t .- mint) ./ (maxt - mint)
    return tau
end

function scaleV2(t1, t2)
    maxt = maximum(filter(!isnan, [t1;t2]))
    mint = minimum(filter(!isnan, [t1;t2]))

    tau1 = (2*pi) .* (t1 .- mint) ./ (maxt - mint)
    tau2 = (2*pi) .* (t2 .- mint) ./ (maxt - mint)
    return tau1, tau2
end

#---------------------------------------------------------------------------
# Dirichlet Kernel implementaion
# wave range from -N:N
# Exploits c(-k) = \bar{c(k)} in the computation so that
# we need only compute 1:N and sum(DiffP) for efficiency

function CFTcorrDK(p, t; kwargs...)
    ## Pre-allocate arrays and check Data
    np = size(p)[1]
    mp = size(p)[2]
    nt = size(t)[1]

    @argcheck size(p) == size(t) DimensionMismatch

    # Re-scale trading times
    tau = scale(t)
    # Computing minimum time change
    # minumum step size to avoid smoothing
    dtau = diff(filter(!isnan, tau))
    taumin = minimum(filter((x) -> x>0, dtau))
    taumax = 2*pi
    # Sampling Freq.
    N0 = taumax/taumin

    # Optional Cutoff - if not specified we use Nyquist Cutoff
    kwargs = Dict(kwargs)

    if haskey(kwargs, :N)
        k = collect(1:1:kwargs[:N])
    else
        k = collect(1:1:floor(N0/2))
    end

    Den = length(k)

    #------------------------------------------------------
    e_pos = zeros(ComplexF64, mp, Den)
    e_neg = zeros(ComplexF64, mp, Den)
    C0 = zeros(ComplexF64, mp, 1)

    for i in 1:mp
        psii = findall(!isnan, p[:,i])
        P = p[psii, i]
        Time = tau[psii, i]
        DiffP = diff(log.(P))

        C0[i] = sum(DiffP)

        C = DiffP' * exp.(-1im * Time[1:(end-1),:] * k')

        e_pos[i,:] = conj(C)
        e_neg[i,:] = C
    end

    c_pos = zeros(ComplexF64, mp, 2*Den + 1)
    c_neg = zeros(ComplexF64, mp, 2*Den + 1)

    c_pos[1,:] = [e_neg[1,:]; C0[1]; e_pos[1,:]]
    c_pos[2,:] = [e_neg[2,:]; C0[2]; e_pos[2,:]]
    c_neg[1,:] = [e_pos[1,:]; C0[1]; e_neg[1,:]]
    c_neg[2,:] = [e_pos[2,:]; C0[2]; e_neg[2,:]]

    Sigma = zeros(ComplexF64, mp, mp)

    Sigma[1, 1] = 1 / (2*Den + 1) * (sum(c_pos[1,:] .* c_neg[1,:]))
    Sigma[1, 2] = 1 / (2*Den + 1) * (sum(c_pos[1,:] .* c_neg[2,:]))
    Sigma[2, 1] = Sigma[1, 2]
    Sigma[2, 2] = 1 / (2*Den + 1) * (sum(c_pos[2,:] .* c_neg[2,:]))
    # Sigma = 0.5 / (2*Den + 1) .* (c_pos*c_pos' + c_neg*c_neg')

    Sigma = real(Sigma)
    var = diag(Sigma)
    sigma = sqrt.(var)
    rho = Sigma ./ (sigma * sigma')

    return rho, Sigma, var
end

#---------------------------------------------------------------------------
# Fejer Kernel implementaion
# wave range from 1:N

function CFTcorrFK(p, t; kwargs...)
    ## Pre-allocate arrays and check Data
    np = size(p)[1]
    mp = size(p)[2]
    nt = size(t)[1]

    @argcheck size(p) == size(t) DimensionMismatch

    # Re-scale trading times
    tau = scale(t)
    # Computing minimum time change
    # minumum step size to avoid smoothing
    dtau = diff(filter(!isnan, tau))
    taumin = minimum(filter((x) -> x>0, dtau))
    taumax = 2*pi
    # Sampling Freq.
    N0 = taumax/taumin

    # Optional Cutoff - if not specified we use Nyquist Cutoff
    kwargs = Dict(kwargs)

    if haskey(kwargs, :N)
        N = kwargs[:N]
    else
        N = trunc(Int, floor(N0/2))
    end

    k = collect(1:1:N)
    Den = length(k)

    #------------------------------------------------------
    c_pos = zeros(ComplexF64, mp, Den)
    c_neg = zeros(ComplexF64, mp, Den)
    C0 = zeros(ComplexF64, mp, 1)

    for i in 1:mp
        psii = findall(!isnan, p[:,i])
        P = p[psii, i]
        Time = tau[psii, i]
        DiffP = diff(log.(P))

        C0[i] = sum(DiffP)

        C = DiffP' * exp.(1im * -Time[1:(end-1),:] * k')

        c_pos[i,:] = conj(C)
        c_neg[i,:] = C
    end

    term1 = zeros(ComplexF64, 1, Den+1)
    term2 = zeros(ComplexF64, 1, Den+1)
    term12 = zeros(ComplexF64, 1, Den+1)

    term1 = [2 .* (1 .- abs.(k)./N) .* c_pos[1,:] .* c_neg[1,:]; C0[1] * C0[1]]
    term2 = [2 .* (1 .- abs.(k)./N) .* c_pos[2,:] .* c_neg[2,:]; C0[2] * C0[2]]
    term12 = [2 .* (1 .- abs.(k)./N) .* c_pos[1,:] .* c_neg[2,:]; C0[1] * C0[2]]

    Sigma = zeros(ComplexF64, mp, mp)
    Sigma[1, 1] = sum(term1)/(N+1)
    Sigma[1, 2] = sum(term12)/(N+1)
    Sigma[2, 1] = Sigma[1, 2]
    Sigma[2, 2] = sum(term2)/(N+1)

    Sigma = real(Sigma)
    var = diag(Sigma)
    sigma = sqrt.(var)
    rho = Sigma ./ (sigma * sigma')

    return rho, Sigma, var
end

#---------------------------------------------------------------------------

# Mancino Sanfelici implementation using for loops
# with the Dirichlet Kernel

function DKcorr(p1, p2, t1, t2; kwargs...)
    # clean the data first
    t1 = filter(!isnan, t1)
    t2 = filter(!isnan, t2)

    p1 = filter(!isnan, p1)
    p2 = filter(!isnan, p2)

    # Re-scale trading times
    tau = scaleV2(t1, t2)
    tau1 = tau[1]
    tau2 = tau[2]
    # Computing minimum time change
    # minumum step size to avoid smoothing
    dtau1 = diff(tau1)
    dtau2 = diff(tau2)
    taumin = minimum([dtau1; dtau2])
    taumax = 2*pi
    # Sampling Freq.
    N0 = taumax/taumin

    # Optional Cutoff - if not specified we use Nyquist Cutoff
    kwargs = Dict(kwargs)

    if haskey(kwargs, :N)
        k = kwargs[:N]
    else
        N = trunc(Int, floor(N0/2))
    end

    #------------------------------------------------------
    r1=diff(log.(p1)); r2=diff(log.(p2))

    c_p1=zeros(ComplexF64,2*N+1,1); c_pp1=zeros(ComplexF64,2*N+1,1);
    c_p2=zeros(ComplexF64,2*N+1,1); c_pp2=zeros(ComplexF64,2*N+1,1);
    for k=1:(2*N+1)
        s=k-N-1;
        c_p1[k]=sum(exp.((-1im*s).*tau1[1:(end-1)]).*r1);
        c_pp1[k]=sum(exp.((1im*s).*tau1[1:(end-1)]).*r1);
        c_p2[k]=sum(exp.((-1im*s).*tau2[1:(end-1)]).*r2);
        c_pp2[k]=sum(exp.((1im*s).*tau2[1:(end-1)]).*r2);
    end

    Sigma = zeros(ComplexF64, 2, 2)
    Sigma[1, 1] = sum(c_p1.*c_pp1)/(2*N+1)
    Sigma[1, 2] = sum(c_p1.*c_pp2)/(2*N+1)
    Sigma[2, 1] = Sigma[1, 2]
    Sigma[2, 2] = sum(c_p2.*c_pp2)/(2*N+1)

    Sigma = real(Sigma)
    var = diag(Sigma)
    sigma = sqrt.(var)
    rho = Sigma ./ (sigma * sigma')

    return rho, Sigma, var
end


#---------------------------------------------------------------------------

# Mancino Sanfelici implementation using for loops
# with the Fejer Kernel

function FKcorr(p1, p2, t1, t2; kwargs...)
    # clean the data first
    t1 = filter(!isnan, t1)
    t2 = filter(!isnan, t2)

    p1 = filter(!isnan, p1)
    p2 = filter(!isnan, p2)

    # Re-scale trading times
    tau = scaleV2(t1, t2)
    tau1 = tau[1]
    tau2 = tau[2]
    # Computing minimum time change
    # minumum step size to avoid smoothing
    dtau1 = diff(tau1)
    dtau2 = diff(tau2)
    taumin = minimum([dtau1; dtau2])
    taumax = 2*pi
    # Sampling Freq.
    N0 = taumax/taumin

    # Optional Cutoff - if not specified we use Nyquist Cutoff
    kwargs = Dict(kwargs)

    if haskey(kwargs, :N)
        N = kwargs[:N]
    else
        N = trunc(Int, floor(N0/2))
    end

    #------------------------------------------------------
    r1=diff(log.(p1)); r2=diff(log.(p2))

    c_p1=zeros(ComplexF64,2*N+1,1); c_pp1=zeros(ComplexF64,2*N+1,1);
    c_p2=zeros(ComplexF64,2*N+1,1); c_pp2=zeros(ComplexF64,2*N+1,1);
    term1=zeros(ComplexF64,2*N+1,1); term2=zeros(ComplexF64,2*N+1,1);
    term12=zeros(ComplexF64,2*N+1,1)
    for k=1:(2*N+1)
        s=k-N-1;
        c_p1[k]=sum(exp.((-1im*s).*tau1[1:(end-1)]).*r1);
        c_pp1[k]=sum(exp.((1im*s).*tau1[1:(end-1)]).*r1);
        c_p2[k]=sum(exp.((-1im*s).*tau2[1:(end-1)]).*r2);
        c_pp2[k]=sum(exp.((1im*s).*tau2[1:(end-1)]).*r2);
        term1[k]=(1-abs(s)/N)*c_p1[k]*c_pp1[k]
        term2[k]=(1-abs(s)/N)*c_p2[k]*c_pp2[k]
        term12[k]=(1-abs(s)/N)*c_p1[k]*c_pp2[k]
    end

    Sigma = zeros(ComplexF64, 2, 2)
    Sigma[1, 1] = sum(term1)/(N+1)
    Sigma[1, 2] = sum(term12)/(N+1)
    Sigma[2, 1] = Sigma[1, 2]
    Sigma[2, 2] = sum(term2)/(N+1)

    Sigma = real(Sigma)
    var = diag(Sigma)
    sigma = sqrt.(var)
    rho = Sigma ./ (sigma * sigma')

    return rho, Sigma, var
end
