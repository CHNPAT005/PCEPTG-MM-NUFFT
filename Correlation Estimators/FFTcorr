## Author: Patrick Chang
# Script file for the MM Fast Fourier Transform
# Supporting Algorithms are at the start of the script
#  Include:
#           - Scale function to re-scale time to [0, 2 \pi]
# Number of Fourier Coefficients used is length of data

#---------------------------------------------------------------------------

### Data Format:
## p = [n x 2] matrix of prices, log returns are computed in the function
# non-trading times are indicated by NaNs
## t = [n x 2] matrix of trading times, non-trading times are indicated by NaNs
# dimensions of p and t must match.

#---------------------------------------------------------------------------

using ArgCheck
using LinearAlgebra
using FFTW

#---------------------------------------------------------------------------

function FFTcorr(p, t; kwargs...)
    ## Pre-allocate arrays and check Data
    np = size(p)[1]
    mp = size(p)[2]
    nt = size(t)[1]

    @argcheck size(p) == size(t) DimensionMismatch

    # Re-scale trading times
    tau = scale(t)
    # Computing minimum time change
    # minumum step size to avoid smoothing
    dtau = diff(filter(!isnan, tau))
    taumin = minimum(filter((x) -> x>0, dtau))
    taumax = 2*pi
    # Sampling Freq.
    N0 = taumax/taumin

    if (iseven(np))
        k = collect(0:1:(np-1)/2)
    else
        k = collect(0:1:(np+1)/2)
    end

    Den = length(k)

    #------------------------------------------------------
    c_pos = zeros(ComplexF64, mp, Den + (Den-1))
    c_neg = zeros(ComplexF64, mp, Den + (Den-1))

    for i in 1:mp
        #c = zeros(ComplexF64, 1, Den)
        DiffP = diff(log.(p[:,i]))
        #c[1:length(DiffP)] = DiffP

        C = rfft(DiffP)

        C_pos = C
        C_neg = conj(C)

        c_pos[i,:] = [C_pos; C_neg[2:end]]
        c_neg[i,:] = [C_neg; C_pos[2:end]]
    end

    Sigma = zeros(ComplexF64, mp, mp)

    # Sigma[1, 1] = 1 / (Den + (Den-1)) * (sum(c_pos[1,:] .* c_neg[1,:]))
    # Sigma[1, 2] = 1 / (Den + (Den-1)) * (sum(c_pos[1,:] .* c_neg[2,:]))
    # Sigma[2, 1] = Sigma[1, 2]
    # Sigma[2, 2] = 1 / (Den + (Den-1)) * (sum(c_pos[2,:] .* c_neg[2,:]))

    Sigma = 0.5 / (Den + (Den-1)) .* (c_pos*c_pos' + c_neg*c_neg')

    Sigma = real(Sigma)
    var = diag(Sigma)
    sigma = sqrt.(var)
    rho = Sigma ./ (sigma * sigma')
    Sigma_rescaled = 1 / N0 .* Sigma

    #dict = Dict("correlation" => rho, "variance" => var)
    return rho, Sigma, var
end

# j1 = CFTcorr(P, t)
# j2 = FFTcorr(P, t)
# j3 = FFTcorrV2(P, t)
# j4 = CFTcorrV2(P[:,1], P[:,2], t[:,1], t[:,2])
# j5 = CFTcorrV3(P[:,1], P[:,2], t[:,1], t[:,2])

# j2 and j4 are the same!!!
# fft Coefficients range from 0 to N-1

# j1 and j3 are only the same when padded up to odd Number
# why when i try make FFT consistent with 2N the error goes up quite a bit
# but error remains low when i choose 2N-1
# possibly something to do with odd and even length(n)?

# j1 = CFTcorr(P, t)
# j2 = CFTcorrV3(P[:,1], P[:,2], t[:,1], t[:,2])  # MS implementaion (Dirichlet Kernel)
#
# j3 = DFTcorr(P, t)
# j4 = FFTcorr(P, t)
#
# j5 = HYcorr(P[:,1], P[:,2], t[:,1], t[:,2])
# j6 = TFTcorr(P, t)
# j7 = CFTcorrV2(P[:,1], P[:,2], t[:,1], t[:,2])
# j8 = CFTcorrV4(P, t)    #1:2N0
# j9 = CFTcorrV2(filter(!isnan, P[:,1]), filter(!isnan, P[:,2]),
#                         filter(!isnan, t[:,1]), filter(!isnan, t[:,2]))
# j10 = CFTcorrV5(filter(!isnan, P[:,1]), filter(!isnan, P[:,2]),
#                         filter(!isnan, t[:,1]), filter(!isnan, t[:,2])) # using Fejer Kernel
# j11 = CFTcorrDK(P, t)
# the pairs produce the same output
# for synchronous CFT and TFT are same when running 1:2N0,
# different when running -2N0:2N0


# j1 = CFTcorrDK(p, t)
# j2 = DKcorr(P[:,1], P[:,2], t[:,1], t[:,2])
#
# j3 = CFTcorrFK(p, t)
# j4 = FKcorr(P[:,1], P[:,2], t[:,1], t[:,2])

function DFT(p)
    n = length(p)
    t = collect(0:1:(n-1))
    if (iseven(n+1))
        k = collect(0:1:(n-1)/2)
    else
        k = collect(0:1:(n+1)/2)
    end
    c = p' * exp.(-2im*pi/n .* t*k')
    c = c'
    return conj(c)
end

function DFT2(p, t, k)
    n = length(p)
    #t = collect(0:1:(n-1))
    k = collect(0:1:(k-1))
    c = p' * exp.(-2im*pi/n .* t*k')
    c = c'
    return conj(c)
end

# m1 = DFT(l1)
# n1 = rfft(l1)
#
# m2 = DFT([l1; 0; 0; 0])
# n2 = rfft([l1; 0; 0; 0])
#
# m3 = DFT2(l1, 13)
# n3 = fft([l1; 0; 0; 0])
#
# m4 = DFT2(l1, 12)
# n4 = fft([l1; 0; 0])
#
# ## Zero padding causes Fourier coeffs to be different than FT
#
# mu = [0.01/86400, 0.01/86400]
# s1 = 0.1/86400
# s2 = 0.2/86400
# Slength = 21
# correlation = collect(-0.99:(2*0.99)/Slength:0.99)
# MMFFT = zeros(1, Slength)
# MMCFT = zeros(1, Slength)
#
# for i in 1:Slength
#     covariance = correlation[i] * sqrt(s1) * sqrt(s2)
#     sig = zeros(2,2)
#     sig[1,1] = s1
#     sig[2,2] = s2
#     sig[1,2] = covariance
#     sig[2,1] = covariance
#
#     P = GBM(5000, mu, sig)
#     t = reshape([collect(1:1:5000.0); collect(1:1:5000.0)], 5000, 2)
#     MMFFT[i] = FFTcorr(P, t)[1][1,2]
#     #MMCFT[i] = CFTcorrDK(P, t)[1][1,2]
# end
