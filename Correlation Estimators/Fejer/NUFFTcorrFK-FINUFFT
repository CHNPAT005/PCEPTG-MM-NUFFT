## Author: Patrick Chang
# Script file for the MM Fast Fourier Transform
# Supporting Algorithms are at the start of the script
#  Include:
#           - Scale function to re-scale time to [0, 2 \pi]
# Number of Fourier Coefficients used is length of data

## Implementation uses FINUFFT package

#---------------------------------------------------------------------------

### Data Format:
## p = [n x 2] matrix of prices, log returns are computed in the function
# non-trading times are indicated by NaNs
## t = [n x 2] matrix of trading times, non-trading times are indicated by NaNs
# dimensions of p and t must match.
## N = Optional input for cutoff frequency
## tol = error tolerance for NUFFT - determines how much spreading

#---------------------------------------------------------------------------

using ArgCheck; using LinearAlgebra; using FINUFFT

#---------------------------------------------------------------------------
### Supporting functions

function scale(t)
    maxt = maximum(filter(!isnan, t))
    mint = minimum(filter(!isnan, t))

    tau = (2*pi) .* (t .- mint) ./ (maxt - mint)
    return tau
end

#---------------------------------------------------------------------------

# Non-uniform Fast Fourier Transform implementaion of the Dirichlet Kernel

function NUFFTcorrFKFINUFFT(p, t, tol; kwargs...)
    ## Pre-allocate arrays and check Data
    np = size(p)[1]
    mp = size(p)[2]
    nt = size(t)[1]

    @argcheck size(p) == size(t) DimensionMismatch

    # Re-scale trading times
    tau = scale(t)
    # Computing minimum time change
    # minumum step size to avoid smoothing
    dtau = diff(filter(!isnan, tau))
    taumin = minimum(filter((x) -> x>0, dtau))
    taumax = 2*pi
    # Sampling Freq.
    N0 = taumax/taumin

    # Optional Cutoff - if not specified we use Nyquist Cutoff
    kwargs = Dict(kwargs)

    if haskey(kwargs, :N)
        k = collect(-kwargs[:N]:1:kwargs[:N])
    else
        k = collect(-floor(N0/2):1:floor(N0/2))
    end

    Den = length(k)

    #------------------------------------------------------
    e_pos = zeros(ComplexF64, mp, Den)
    e_neg = zeros(ComplexF64, mp, Den)

    for i in 1:mp
        psii = findall(!isnan, p[:,i])
        P = p[psii, i]
        Time = tau[psii, i]
        DiffP = complex(diff(log.(P)))
        Time = Time[1:(end-1)]

        C = nufft1d1(Time, DiffP, -1, tol, Den)

        e_pos[i,:] = C
        e_neg[i,:] = conj(C)
    end

    # term1 = zeros(ComplexF64, 1, Den)
    # term2 = zeros(ComplexF64, 1, Den)
    # term12 = zeros(ComplexF64, 1, Den)

    N = (Den-1)/2

    # term1 = (1 .- abs.(k)./N) .* e_pos[1,:] .* e_neg[1,:]
    # term2 = (1 .- abs.(k)./N) .* e_pos[2,:] .* e_neg[2,:]
    # term12 = (1 .- abs.(k)./N) .* e_pos[1,:] .* e_neg[2,:]
    #
    # Sigma = zeros(ComplexF64, mp, mp)
    # Sigma[1, 1] = sum(term1)/(N+1)
    # Sigma[1, 2] = sum(term12)/(N+1)
    # Sigma[2, 1] = Sigma[1, 2]
    # Sigma[2, 2] = sum(term2)/(N+1)

    for i in 1:mp
        e_pos[i,:] = sqrt.(1 .- abs.(k)./N) .* e_pos[i,:]
        e_neg[i,:] = sqrt.(1 .- abs.(k)./N) .* e_neg[i,:]
    end

    Sigma = 0.5/(N+1) .* (e_pos*e_pos' + e_neg*e_neg')

    Sigma = real(Sigma)
    var = diag(Sigma)
    sigma = sqrt.(var)
    rho = Sigma ./ (sigma * sigma')

    return rho, Sigma, var
end
