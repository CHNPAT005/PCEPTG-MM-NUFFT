## Author: Patrick Chang
# Script file for the MM Fast Fourier Transform with Zero Padding
# Supporting Algorithms are at the start of the script
#  Include:
#           - Scale function to re-scale time to [0, 2 \pi]
# Number of Fourier Coefficients used is length of data

#---------------------------------------------------------------------------

### Data Format:
## p = [n x 2] matrix of prices, log returns are computed in the function
# non-trading times are indicated by NaNs

#---------------------------------------------------------------------------

using ArgCheck; using LinearAlgebra;
using FFTW

#---------------------------------------------------------------------------
### Supporting functions

function scale(t)
    maxt = maximum(filter(!isnan, t))
    mint = minimum(filter(!isnan, t))

    tau = (2*pi) .* (t .- mint) ./ (maxt - mint)
    return tau
end

function zero_pad(cj, xj, N0)
    res = zeros(N0, 1)
    nj = length(xj)
    for j in 1:nj
        pos = Int(round(xj[j] * (N0/(2*pi))))
        res[pos+1] = cj[j]
    end
    return res
end
#ZPP = zero_pad(DiffP, tau[psii, 1], Int(ceil(N0)))
#---------------------------------------------------------------------------

# Fast Fourier Transform (with Zero Padding) implementaion of the Fejer Kernel
# Can be used for asynchronous data
# No option for optional cutoff (N)

function FFTZPcorrFK(p, t)
    ## Pre-allocate arrays and check Data
    np = size(p)[1]
    mp = size(p)[2]
    nt = size(t)[1]

    #@argcheck size(p) == size(t) DimensionMismatch

    # Re-scale trading times
    tau = scale(t)
    # Computing minimum time change
    # minumum step size to avoid smoothing
    dtau = diff(filter(!isnan, tau))
    taumin = minimum(filter((x) -> x>0, dtau))
    taumax = 2*pi
    # Sampling Freq.
    N0 = taumax/taumin

    k = collect(-floor(N0/2):1:floor(N0/2))

    Den = length(k)

    #------------------------------------------------------
    c_pos = zeros(ComplexF64, mp, Den)
    c_neg = zeros(ComplexF64, mp, Den)

    for i in 1:mp
        psii = findall(!isnan, p[:,i])
        P = p[psii, i]
        DiffP = diff(log.(P))
        psii = psii[1:(end-1)]
        Time = tau[psii, i]
        ZP = zeros(Den, 1)

        ZP[1:Int(floor(N0))] = zero_pad(DiffP, Time, Int(floor(N0)))

        C = fft(ZP)

        C_pos = C
        C_neg = conj(C)

        c_pos[i,:] = C_pos
        c_neg[i,:] = C_neg
    end

    N = floor(N0/2)
    k = fftfreq(Den, 1) * Den

    # ------------

    # 1) this is useful for multiple assets - but can face DomainError due to the sqrt
    #   and issues with rounding errors
    # for i in 1:mp
    #     c_pos[i,:] = sqrt.(1 .- abs.(k)./N) .* c_pos[i,:]
    #     c_neg[i,:] = sqrt.(1 .- abs.(k)./N) .* c_neg[i,:]
    # end
    #
    # Sigma = 0.5/(N+1) .* (c_pos*c_pos' + c_neg*c_neg')

    # ------------

    # 2) uncomment and use this if facing DomainError - but this only works for two asset case
    t1 = (1 .- abs.(k)./N) .* c_pos[1,:] .* c_neg[1,:]
    t2 = (1 .- abs.(k)./N) .* c_pos[2,:] .* c_neg[2,:]
    t12 = (1 .- abs.(k)./N) .* c_pos[1,:] .* c_neg[2,:]

    Sigma = zeros(ComplexF64, mp, mp)
    Sigma[1,1] = sum(t1) / (N+1)
    Sigma[2,2] = sum(t2) / (N+1)
    Sigma[1,2] = sum(t12) / (N+1)
    Sigma[2,1] = Sigma[1,2]

    # ------------

    Sigma = real(Sigma)
    var = diag(Sigma)
    sigma = sqrt.(var)
    rho = Sigma ./ (sigma * sigma')

    return rho, Sigma, var
end
