## Author: Patrick Chang
# Script file to test the impact of Ïµ on the correlation estimate
# for various averaging kernels using the Vectorized code as a baseline.
# We investigate the synchronous case, down-sampled case and arrival-time
# representation case.

#---------------------------------------------------------------------------

using LinearAlgebra; using LaTeXStrings; using StatsBase; using Random;
using Statistics; using Distributions; using ProgressMeter; using JLD

#---------------------------------------------------------------------------

cd("/Users/patrickchang1/PCEPTG-MM-NUFFT")

include("../Correlation Estimators/Dirichlet/CFTcorrDK")
include("../Correlation Estimators/Dirichlet/FFTZPcorrDK")
include("../Correlation Estimators/Dirichlet/NUFFTcorrDK-FINUFFT")
include("../Correlation Estimators/Dirichlet/NUFFTcorrDK-FGG")
include("../Correlation Estimators/Dirichlet/NUFFTcorrDK-KB")

include("../Correlation Estimators/Fejer/CFTcorrFK")
include("../Correlation Estimators/Fejer/FFTZPcorrFK")
include("../Correlation Estimators/Fejer/NUFFTcorrFK-FINUFFT")
include("../Correlation Estimators/Fejer/NUFFTcorrFK-FGG")
include("../Correlation Estimators/Fejer/NUFFTcorrFK-KB")

include("../Monte Carlo Simulation Algorithms/GBM")

#---------------------------------------------------------------------------
## Dirichlet
#---------------------------------------------------------------------------

mu = [0.01/86400, 0.01/86400]
sigma = [0.1/86400 sqrt(0.1/86400)*0.35*sqrt(0.2/86400);
        sqrt(0.1/86400)*0.35*sqrt(0.2/86400) 0.2/86400]

#--------------------

n1 = collect(-1:-1:-14)
tol = 10.0.^n1
reps = 1000

## Synchronous Case
CFTaccDKSyn = zeros(1, reps)
ZFFTaccDKSyn = zeros(1, reps)

FGGaccDKSyn = zeros(length(n1), reps)
KBaccDKSyn = zeros(length(n1), reps)
FINUFFTaccDKSyn = zeros(length(n1), reps)

# Compute
@showprogress "Computing..." for j in 1:reps
    P = GBM(10000, mu, sigma, seed = j)
    t = reshape([collect(1:1:10000.0); collect(1:1:10000.0)], 10000, 2)

    CFTaccDKSyn[j] = CFTcorrDK(P, t)[1][1,2]
    ZFFTaccDKSyn[j] = FFTZPcorrDK(P, t)[1][1,2]

    for i in 1:length(n1)
        FGGaccDKSyn[i, j] = NUFFTcorrDKFGG(P, t, tol = tol[i])[1][1,2]
        KBaccDKSyn[i, j] = NUFFTcorrDKKB(P, t, tol = tol[i])[1][1,2]
        FINUFFTaccDKSyn[i, j] = NUFFTcorrDKFINUFFT(P, t, tol = tol[i])[1][1,2]
    end
end

# Save
save("Computed Data/Accuracy/CFTaccDKSyn.jld", "CFTaccDKSyn", CFTaccDKSyn)
save("Computed Data/Accuracy/ZFFTaccDKSyn.jld", "ZFFTaccDKSyn", ZFFTaccDKSyn)
save("Computed Data/Accuracy/FGGaccDKSyn.jld", "FGGaccDKSyn", FGGaccDKSyn)
save("Computed Data/Accuracy/KBaccDKSyn.jld", "KBaccDKSyn", KBaccDKSyn)
save("Computed Data/Accuracy/FINUFFTaccDKSyn.jld", "FINUFFTaccDKSyn", FINUFFTaccDKSyn)

# Load
CFTaccDKSyn = load("Computed Data/Accuracy/CFTaccDKSyn.jld")
CFTaccDKSyn = CFTaccDKSyn["CFTaccDKSyn"]

ZFFTaccDKSyn = load("Computed Data/Accuracy/ZFFTaccDKSyn.jld")
ZFFTaccDKSyn = ZFFTaccDKSyn["ZFFTaccDKSyn"]

FGGaccDKSyn = load("Computed Data/Accuracy/FGGaccDKSyn.jld")
FGGaccDKSyn = FGGaccDKSyn["FGGaccDKSyn"]

KBaccDKSyn = load("Computed Data/Accuracy/KBaccDKSyn.jld")
KBaccDKSyn = KBaccDKSyn["KBaccDKSyn"]

FINUFFTaccDKSyn = load("Computed Data/Accuracy/FINUFFTaccDKSyn.jld")
FINUFFTaccDKSyn = FINUFFTaccDKSyn["FINUFFTaccDKSyn"]

# Plot
xticklabel = [L"10^{-1}", L"10^{-2}", L"10^{-3}", L"10^{-4}", L"10^{-5}", L"10^{-6}", L"10^{-7}", L"10^{-8}", L"10^{-9}", L"10^{-10}", L"10^{-11}", L"10^{-12}", L"10^{-13}", L"10^{-14}"]

# q = quantile.(TDist(reps), [0.975])
styles = filter((s->begin
                s in Plots.supported_styles()
            end), [:solid, :dash, :dot])
styles = reshape(styles, 1, length(styles))
col = reshape([:blue, :red, :green], 1, 3)

p1 = plot(n1, [mean(FGGaccDKSyn .- CFTaccDKSyn, dims = 2) mean(KBaccDKSyn .- CFTaccDKSyn, dims = 2) mean(FINUFFTaccDKSyn .- CFTaccDKSyn, dims = 2)],
 label = ["FGG" "KB" "FINUFFT"], legendtitle=L"\textrm{Method} (*)",
  legend=:topleft, line=(2, styles), color = col,# fillalpha=.2,
   xticks = (n1, xticklabel), formatter = :plain)
hline!(p1, [mean(ZFFTaccDKSyn .- CFTaccDKSyn)], label = "ZFFT", line=(2, [:dashdotdot]))
title!(p1, L"\textrm{\sffamily (a) Accuracy and tolerance (Dirichlet, Synchronous)}")
ylabel!(p1, L"\textrm{Accuracy} (\overline{\rho_{*} - \rho_{v}})")
xlabel!(p1, L"\textrm{Tolerance} (\epsilon)")
plot(p1, annotations=(-13, -0.000005, Plots.text(latexstring("\$\\overline{\\rho_{v}} = $(round(mean(CFTaccDKSyn), digits = 4))\$"), :left)))

savefig(p1, "Plots/AccSynDK.pdf")



## Down-sampled Case
n1 = collect(-1:-1:-14)
tol = 10.0.^n1
reps = 1000

CFTaccDKDS = zeros(1, reps)
ZFFTaccDKDS = zeros(1, reps)

FGGaccDKDS = zeros(length(n1), reps)
KBaccDKDS = zeros(length(n1), reps)
FINUFFTaccDKDS = zeros(length(n1), reps)

# Compute
@showprogress "Computing..." for j in 1:reps
    P = GBM(10000, mu, sigma, seed = j)
    t = reshape([collect(1:1:10000.0); collect(1:1:10000.0)], 10000, 2)

    Random.seed!(j)
    rm1 = sample(2:9999, 4000, replace = false)
    Random.seed!(j+reps)
    rm2 = sample(2:9999, 4000, replace = false)

    P[rm1, 1] .= NaN
    t[rm1, 1] .= NaN
    P[rm2, 2] .= NaN
    t[rm2, 2] .= NaN

    CFTaccDKDS[j] = CFTcorrDK(P, t)[1][1,2]
    ZFFTaccDKDS[j] = FFTZPcorrDK(P, t)[1][1,2]

    for i in 1:length(n1)
        FGGaccDKDS[i, j] = NUFFTcorrDKFGG(P, t, tol = tol[i])[1][1,2]
        KBaccDKDS[i, j] = NUFFTcorrDKKB(P, t, tol = tol[i])[1][1,2]
        FINUFFTaccDKDS[i, j] = NUFFTcorrDKFINUFFT(P, t, tol = tol[i])[1][1,2]
    end
end

# Save
save("Computed Data/Accuracy/CFTaccDKDS.jld", "CFTaccDKDS", CFTaccDKDS)
save("Computed Data/Accuracy/ZFFTaccDKDS.jld", "ZFFTaccDKDS", ZFFTaccDKDS)
save("Computed Data/Accuracy/FGGaccDKDS.jld", "FGGaccDKDS", FGGaccDKDS)
save("Computed Data/Accuracy/KBaccDKDS.jld", "KBaccDKDS", KBaccDKDS)
save("Computed Data/Accuracy/FINUFFTaccDKDS.jld", "FINUFFTaccDKDS", FINUFFTaccDKDS)

# Load
CFTaccDKDS = load("Computed Data/Accuracy/CFTaccDKDS.jld")
CFTaccDKDS = CFTaccDKDS["CFTaccDKDS"]

ZFFTaccDKDS = load("Computed Data/Accuracy/ZFFTaccDKDS.jld")
ZFFTaccDKDS = ZFFTaccDKDS["ZFFTaccDKDS"]

FGGaccDKDS = load("Computed Data/Accuracy/FGGaccDKDS.jld")
FGGaccDKDS = FGGaccDKDS["FGGaccDKDS"]

KBaccDKDS = load("Computed Data/Accuracy/KBaccDKDS.jld")
KBaccDKDS = KBaccDKDS["KBaccDKDS"]

FINUFFTaccDKDS = load("Computed Data/Accuracy/FINUFFTaccDKDS.jld")
FINUFFTaccDKDS = FINUFFTaccDKDS["FINUFFTaccDKDS"]

# Plot
xticklabel = [L"10^{-1}", L"10^{-2}", L"10^{-3}", L"10^{-4}", L"10^{-5}", L"10^{-6}", L"10^{-7}", L"10^{-8}", L"10^{-9}", L"10^{-10}", L"10^{-11}", L"10^{-12}", L"10^{-13}", L"10^{-14}"]

# q = quantile.(TDist(reps), [0.975])
styles = filter((s->begin
                s in Plots.supported_styles()
            end), [:solid, :dash, :dot])
styles = reshape(styles, 1, length(styles))
col = reshape([:blue, :red, :green], 1, 3)

p1 = plot(n1, [mean(FGGaccDKDS .- CFTaccDKDS, dims = 2) mean(KBaccDKDS .- CFTaccDKDS, dims = 2) mean(FINUFFTaccDKDS .- CFTaccDKDS, dims = 2)],
 label = ["FGG" "KB" "FINUFFT"], legendtitle=L"\textrm{Method} (*)",
  legend=:topleft, line=(2, styles), color = col,# fillalpha=.2,
   xticks = (n1, xticklabel))
hline!(p1, [mean(ZFFTaccDKDS .- CFTaccDKDS)], label = "ZFFT", line=(2, [:dashdotdot]))
title!(p1, L"\textrm{\sffamily (c) Accuracy and tolerance (Dirichlet, Down-Sampled 40\%)}")
ylabel!(p1, L"\textrm{Accuracy} (\overline{\rho_{*} - \rho_{v}})")
xlabel!(p1, L"\textrm{Tolerance} (\epsilon)")
plot(p1, annotations=(-13, -0.004, Plots.text(latexstring("\$\\overline{\\rho_{v}} = $(round(mean(CFTaccDKDS), digits = 4))\$"), :left)))


savefig(p1, "Plots/AccDSDK.pdf")




#---------------------------------------------------------------------------
## Fejer
#---------------------------------------------------------------------------

mu = [0.01/86400, 0.01/86400]
sigma = [0.1/86400 sqrt(0.1/86400)*0.35*sqrt(0.2/86400);
        sqrt(0.1/86400)*0.35*sqrt(0.2/86400) 0.2/86400]

#--------------------

n1 = collect(-1:-1:-14)
tol = 10.0.^n1
reps = 1000

## Synchronous Case
CFTaccFKSyn = zeros(1, reps)
ZFFTaccFKSyn = zeros(1, reps)

FGGaccFKSyn = zeros(length(n1), reps)
KBaccFKSyn = zeros(length(n1), reps)
FINUFFTaccFKSyn = zeros(length(n1), reps)

# Compute
@showprogress "Computing..." for j in 1:reps
    P = GBM(10000, mu, sigma, seed = j)
    t = reshape([collect(1:1:10000.0); collect(1:1:10000.0)], 10000, 2)

    CFTaccFKSyn[j] = CFTcorrFK(P, t)[1][1,2]
    ZFFTaccFKSyn[j] = FFTZPcorrFK(P, t)[1][1,2]

    for i in 1:length(n1)
        FGGaccFKSyn[i, j] = NUFFTcorrFKFGG(P, t, tol = tol[i])[1][1,2]
        KBaccFKSyn[i, j] = NUFFTcorrFKKB(P, t, tol = tol[i])[1][1,2]
        FINUFFTaccFKSyn[i, j] = NUFFTcorrFKFINUFFT(P, t, tol = tol[i])[1][1,2]
    end
end

# Save
save("Computed Data/Accuracy/CFTaccFKSyn.jld", "CFTaccFKSyn", CFTaccFKSyn)
save("Computed Data/Accuracy/ZFFTaccFKSyn.jld", "ZFFTaccFKSyn", ZFFTaccFKSyn)
save("Computed Data/Accuracy/FGGaccFKSyn.jld", "FGGaccFKSyn", FGGaccFKSyn)
save("Computed Data/Accuracy/KBaccFKSyn.jld", "KBaccFKSyn", KBaccFKSyn)
save("Computed Data/Accuracy/FINUFFTaccFKSyn.jld", "FINUFFTaccFKSyn", FINUFFTaccFKSyn)

# Load
CFTaccFKSyn = load("Computed Data/Accuracy/CFTaccFKSyn.jld")
CFTaccFKSyn = CFTaccFKSyn["CFTaccFKSyn"]

ZFFTaccFKSyn = load("Computed Data/Accuracy/ZFFTaccFKSyn.jld")
ZFFTaccFKSyn = ZFFTaccFKSyn["ZFFTaccFKSyn"]

FGGaccFKSyn = load("Computed Data/Accuracy/FGGaccFKSyn.jld")
FGGaccFKSyn = FGGaccFKSyn["FGGaccFKSyn"]

KBaccFKSyn = load("Computed Data/Accuracy/KBaccFKSyn.jld")
KBaccFKSyn = KBaccFKSyn["KBaccFKSyn"]

FINUFFTaccFKSyn = load("Computed Data/Accuracy/FINUFFTaccFKSyn.jld")
FINUFFTaccFKSyn = FINUFFTaccFKSyn["FINUFFTaccFKSyn"]

# Plot
xticklabel = [L"10^{-1}", L"10^{-2}", L"10^{-3}", L"10^{-4}", L"10^{-5}", L"10^{-6}", L"10^{-7}", L"10^{-8}", L"10^{-9}", L"10^{-10}", L"10^{-11}", L"10^{-12}", L"10^{-13}", L"10^{-14}"]

# q = quantile.(TDist(reps), [0.975])
styles = filter((s->begin
                s in Plots.supported_styles()
            end), [:solid, :dash, :dot])
styles = reshape(styles, 1, length(styles))
col = reshape([:blue, :red, :green], 1, 3)

p1 = plot(n1, [mean(FGGaccFKSyn .- CFTaccFKSyn, dims = 2) mean(KBaccFKSyn .- CFTaccFKSyn, dims = 2) mean(FINUFFTaccFKSyn .- CFTaccFKSyn, dims = 2)],
 label = ["FGG" "KB" "FINUFFT"], legendtitle=L"\textrm{Method} (*)",
  legend=:topleft, line=(2, styles), color = col,
   xticks = (n1, xticklabel), formatter = :plain)
hline!(p1, [mean(ZFFTaccFKSyn .- CFTaccFKSyn)], label = "ZFFT", line=(2, [:dashdotdot]))
title!(p1, L"\textrm{\sffamily (b) Accuracy and tolerance (Fej\'{e}r, Synchronous)}")
ylabel!(p1, L"\textrm{Accuracy} (\overline{\rho_{*} - \rho_{v}})")
xlabel!(p1, L"\textrm{Tolerance} (\epsilon)")
plot(p1, annotations=(-13, -0.000015, Plots.text(latexstring("\$\\overline{\\rho_{v}} = $(round(mean(CFTaccFKSyn), digits = 4))\$"), :left)))

savefig(p1, "Plots/AccSynFK.pdf")



## Down-sampled Case
n1 = collect(-1:-1:-14)
tol = 10.0.^n1
reps = 1000

CFTaccFKDS = zeros(1, reps)
ZFFTaccFKDS = zeros(1, reps)

FGGaccFKDS = zeros(length(n1), reps)
KBaccFKDS = zeros(length(n1), reps)
FINUFFTaccFKDS = zeros(length(n1), reps)

# Compute
@showprogress "Computing..." for j in 1:reps
    P = GBM(10000, mu, sigma, seed = j)
    t = reshape([collect(1:1:10000.0); collect(1:1:10000.0)], 10000, 2)

    Random.seed!(j)
    rm1 = sample(2:9999, 4000, replace = false)
    Random.seed!(j+reps)
    rm2 = sample(2:9999, 4000, replace = false)

    P[rm1, 1] .= NaN
    t[rm1, 1] .= NaN
    P[rm2, 2] .= NaN
    t[rm2, 2] .= NaN

    CFTaccFKDS[j] = CFTcorrFK(P, t)[1][1,2]
    ZFFTaccFKDS[j] = FFTZPcorrFK(P, t)[1][1,2]

    for i in 1:length(n1)
        FGGaccFKDS[i, j] = NUFFTcorrFKFGG(P, t, tol = tol[i])[1][1,2]
        KBaccFKDS[i, j] = NUFFTcorrFKKB(P, t, tol = tol[i])[1][1,2]
        FINUFFTaccFKDS[i, j] = NUFFTcorrFKFINUFFT(P, t, tol = tol[i])[1][1,2]
    end
end

# Save
save("Computed Data/Accuracy/CFTaccFKDS.jld", "CFTaccFKDS", CFTaccFKDS)
save("Computed Data/Accuracy/ZFFTaccFKDS.jld", "ZFFTaccFKDS", ZFFTaccFKDS)
save("Computed Data/Accuracy/FGGaccFKDS.jld", "FGGaccFKDS", FGGaccFKDS)
save("Computed Data/Accuracy/KBaccFKDS.jld", "KBaccFKDS", KBaccFKDS)
save("Computed Data/Accuracy/FINUFFTaccFKDS.jld", "FINUFFTaccFKDS", FINUFFTaccFKDS)

# Load
CFTaccFKDS = load("Computed Data/Accuracy/CFTaccFKDS.jld")
CFTaccFKDS = CFTaccFKDS["CFTaccFKDS"]

ZFFTaccFKDS = load("Computed Data/Accuracy/ZFFTaccFKDS.jld")
ZFFTaccFKDS = ZFFTaccFKDS["ZFFTaccFKDS"]

FGGaccFKDS = load("Computed Data/Accuracy/FGGaccFKDS.jld")
FGGaccFKDS = FGGaccFKDS["FGGaccFKDS"]

KBaccFKDS = load("Computed Data/Accuracy/KBaccFKDS.jld")
KBaccFKDS = KBaccFKDS["KBaccFKDS"]

FINUFFTaccFKDS = load("Computed Data/Accuracy/FINUFFTaccFKDS.jld")
FINUFFTaccFKDS = FINUFFTaccFKDS["FINUFFTaccFKDS"]

# Plot
xticklabel = [L"10^{-1}", L"10^{-2}", L"10^{-3}", L"10^{-4}", L"10^{-5}", L"10^{-6}", L"10^{-7}", L"10^{-8}", L"10^{-9}", L"10^{-10}", L"10^{-11}", L"10^{-12}", L"10^{-13}", L"10^{-14}"]

# q = quantile.(TDist(reps), [0.975])
styles = filter((s->begin
                s in Plots.supported_styles()
            end), [:solid, :dash, :dot])
styles = reshape(styles, 1, length(styles))
col = reshape([:blue, :red, :green], 1, 3)

p1 = plot(n1, [mean(FGGaccFKDS .- CFTaccFKDS, dims = 2) mean(KBaccFKDS .- CFTaccFKDS, dims = 2) mean(FINUFFTaccFKDS .- CFTaccFKDS, dims = 2)],
 label = ["FGG" "KB" "FINUFFT"], legendtitle=L"\textrm{Method} (*)",
  legend=:topleft, line=(2, styles), color = col,# fillalpha=.2,
   xticks = (n1, xticklabel))
hline!(p1, [mean(ZFFTaccFKDS .- CFTaccFKDS)], label = "ZFFT", line=(2, [:dashdotdot]))
title!(p1, L"\textrm{\sffamily (d) Accuracy and tolerance (Fej\'{e}r, Down-Sampled 40\%)}")
ylabel!(p1, L"\textrm{Accuracy} (\overline{\rho_{*} - \rho_{v}})")
xlabel!(p1, L"\textrm{Tolerance} (\epsilon)")
plot(p1, annotations=(-13, -0.003, Plots.text(latexstring("\$\\overline{\\rho_{v}} = $(round(mean(CFTaccFKDS), digits = 4))\$"), :left)))


savefig(p1, "Plots/AccDSFK.pdf")























## Asynchronous Case - Random Exponential
n1 = collect(-1:-1:-14)
tol = 10.0.^n1
reps = 10
# N = 160

function rexp(n, mean)
    t = -mean .* log.(rand(n))
end

CFTaccDKRE = zeros(1, reps)
ZFFTaccDKRE = zeros(1, reps)

FGGaccDKRE = zeros(length(n1), reps)
KBaccDKRE = zeros(length(n1), reps)
FINUFFTaccDKRE = zeros(length(n1), reps)

for j in 1:reps
    P = GBM(10000, mu, sigma, seed = j)
    t = reshape([collect(1:1:10000.0); collect(1:1:10000.0)], 10000, 2)

    Random.seed!(j)
    t1 = rexp(10000, 15)
    t1 = cumsum(t1)
    t1 = filter((x) -> x < 10000, t1)

    Random.seed!(j+reps)
    t2 = rexp(10000, 45)
    t2 = cumsum(t2)
    t2 = filter((x) -> x < 10000, t2)

    p1 = P[Int.(floor.(t1)), 1]
    p2 = P[Int.(floor.(t2)), 2]

    D = maximum([length(t1); length(t2)]) - minimum([length(t1); length(t2)])
    if length(t1) < length(t2)
        t1 = [t1; repeat([NaN], D)]
        p1 = [p1; repeat([NaN], D)]
    else
        t2 = [t2; repeat([NaN], D)]
        p2 = [p2; repeat([NaN], D)]
    end

    P = [p1 p2]
    t = [t1 t2]

    CFTaccDKRE[j] = CFTcorrDK(P, t)[1][1,2]
    #ZFFTaccDKRE[j] = FFTZPcorrDK(P, t, N = 160)[1][1,2]

    for i in 1:length(n1)
        FGGaccDKRE[i, j] = NUFFTcorrDKFGG(P, t, tol = tol[i])[1][1,2]
        KBaccDKRE[i, j] = NUFFTcorrDKKB(P, t, tol = tol[i])[1][1,2]
        FINUFFTaccDKRE[i, j] = NUFFTcorrDKFINUFFT(P, t, tol = tol[i])[1][1,2]
    end
end

xticklabel = [L"10^{-1}", L"10^{-2}", L"10^{-3}", L"10^{-4}", L"10^{-5}", L"10^{-6}", L"10^{-7}", L"10^{-8}", L"10^{-9}", L"10^{-10}", L"10^{-11}", L"10^{-12}", L"10^{-13}", L"10^{-14}"]

styles = filter((s->begin
                s in Plots.supported_styles()
            end), [:solid, :dash, :dot])
styles = reshape(styles, 1, length(styles))


p1 = plot(n1, [mean(FGGaccDKRE, dims = 2) mean(KBaccDKRE, dims = 2) mean(FINUFFTaccDKRE, dims = 2)],
 label = ["FGG" "KB" "FINUFFT"], legendtitle="Method",
  legend=:topleft, line=(2, styles),
   xticks = (n1, xticklabel))#, ylims = (0.0, 1.0))
hline!(p1, [mean(CFTaccDKRE)], label = "CFT", line=(2, [:dashdot]))
#hline!(p1, [mean(ZFFTaccDKRE)], label = "ZFFT", line=(2, [:dashdotdot]))
title!(p1, L"\textrm{\sffamily (e) Correlation and tolerance (Dirichlet, Random exponential)}")
ylabel!(p1, "Correlation (\\rho)")
xlabel!(p1, "Tolerance \\epsilon")

savefig(p1, "Plots/AccREDK.pdf")



n=100; xr= 10*rand(n); yr= 10*rand(n); zr= Float64[ sin(xr[i])+cos(yr[i]) for i=1:n];
surface( xr, yr, zr, size=[800,480] )

n1 = collect(-1:-1:-5)
tol = 10.0.^n1
x= n1; y= collect(50:10:100); f(x,y)= test(x, y);
p1= surface( x, y, f, camera=(30,50), legend=true, title="testing", zlabel = "ok")#, size=[800,500] )
ylabel!(p1, "N")
xlabel!(p1, "tol")

x = sort(n1)
y = sort(collect(50:10:100))
contour(x,y,f, size=[800,480])

annotations= [ (x[i],y[j],text(round(f(x[i],y[j]) , digits = 5))) for i=1:length(x) for j=1:length(y)];
heatmap( x, y, f, size=[800,480], annotations=annotations, legend=true )

savefig(p1, "Plots/test3D.pdf")


function test(tol, N)
    tol = 10.0^tol
    vec = zeros(5)
    for j in 1:5
        P = GBM(86400, mu, sigma, seed = j)

        Random.seed!(j)
        t1 = [1; rexp(86400, 15)]
        t1 = cumsum(t1)
        t1 = filter((x) -> x < 86400, t1)

        Random.seed!(j+reps)
        t2 = [1; rexp(86400, 45)]
        t2 = cumsum(t2)
        t2 = filter((x) -> x < 86400, t2)

        p1 = P[Int.(floor.(t1)), 1]
        p2 = P[Int.(floor.(t2)), 2]

        D = maximum([length(t1); length(t2)]) - minimum([length(t1); length(t2)])
        if length(t1) < length(t2)
            t1 = [t1; repeat([NaN], D)]
            p1 = [p1; repeat([NaN], D)]
        else
            t2 = [t2; repeat([NaN], D)]
            p2 = [p2; repeat([NaN], D)]
        end

        P = [p1 p2]
        t = [t1 t2]

        vec[j] = NUFFTcorrDKFGG(P, t, N=N, tol = tol)[1][1,2]
    end
    return mean(vec)
end
