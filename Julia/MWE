## Script file to show that ranging from -N/2:N/2
# is the same as 1:2N
# this implementaion recovers the Dirichlet Kernel
# it does not actually recover the Fejer Kernel

using Random
using LinearAlgebra
using ArgCheck

function GBM(n, mu, sigma; kwargs...)
    # n - simlulation length
    # mu - vector input of the drift component
    # sigma - covariance matrix of the stocks
    # startprice - starting price for the assets

    # all inputs must have appropriate dimensions

    k = size(sigma)[1]

    kwargs = Dict(kwargs)

    if haskey(kwargs, :startprice)
        startprice = kwargs[:startprice]
    else
        startprice = fill(100.0, (k,1))
    end

    if haskey(kwargs, :seed)
        seed = kwargs[:seed]
    else
        seed = 1
    end

    mu = reshape(mu, k, 1)
    sigma = reshape(sigma, k, k)
    sigma2 = reshape(diag(sigma), k, 1)

    P = zeros(n, k)
    P[1,:] = startprice

    A = cholesky(sigma).U
    b = mu - sigma2./2

    Random.seed!(seed)
    Z = randn(k, n-1)

    for i in 2:n
        z = Z[:,i-1]
        X = b + A * z
        P[i,:] = P[i-1,:] .* exp.(X)
    end
    return P
end

function scale(t)
    maxt = maximum(filter(!isnan, t))
    mint = minimum(filter(!isnan, t))

    tau = (2*pi) .* (t .- mint) ./ (maxt - mint)
    return tau
end

# Corrected range from -N/2:N/2
function CFTcorrDK(p, t; kwargs...)
    ## Pre-allocate arrays and check Data
    np = size(p)[1]
    mp = size(p)[2]
    nt = size(t)[1]

    @argcheck size(p) == size(t) DimensionMismatch

    # Re-scale trading times
    tau = scale(t)
    # Computing minimum time change
    # minumum step size to avoid smoothing
    dtau = diff(filter(!isnan, tau))
    taumin = minimum(filter((x) -> x>0, dtau))
    taumax = 2*pi
    # Sampling Freq.
    N0 = taumax/taumin

    # Optional Cutoff - if not specified we use Nyquist Cutoff
    kwargs = Dict(kwargs)

    if haskey(kwargs, :N)
        k = collect(1:1:kwargs[:N])
    else
        k = collect(1:1:floor(N0/2))
    end

    Den = length(k)

    #------------------------------------------------------
    e_pos = zeros(ComplexF64, mp, Den)
    e_neg = zeros(ComplexF64, mp, Den)
    C0 = zeros(ComplexF64, mp, 1)

    for i in 1:mp
        psii = findall(!isnan, p[:,i])
        P = p[psii, i]
        Time = tau[psii, i]
        DiffP = diff(log.(P))

        C0[i] = sum(DiffP)

        C = DiffP' * exp.(-1im * Time[1:(end-1),:] * k')

        e_pos[i,:] = conj(C)
        e_neg[i,:] = C
    end

    c_pos = zeros(ComplexF64, mp, 2*Den + 1)
    c_neg = zeros(ComplexF64, mp, 2*Den + 1)

    c_pos[1,:] = [e_neg[1,:]; C0[1]; e_pos[1,:]]
    c_pos[2,:] = [e_neg[2,:]; C0[2]; e_pos[2,:]]
    c_neg[1,:] = [e_pos[1,:]; C0[1]; e_neg[1,:]]
    c_neg[2,:] = [e_pos[2,:]; C0[2]; e_neg[2,:]]

    Sigma = zeros(ComplexF64, mp, mp)

    Sigma[1, 1] = 1 / (2*Den + 1) * (sum(c_pos[1,:] .* c_neg[1,:]))
    Sigma[1, 2] = 1 / (2*Den + 1) * (sum(c_pos[1,:] .* c_neg[2,:]))
    Sigma[2, 1] = Sigma[1, 2]
    Sigma[2, 2] = 1 / (2*Den + 1) * (sum(c_pos[2,:] .* c_neg[2,:]))
    # Sigma = 0.5 / (2*Den + 1) .* (c_pos*c_pos' + c_neg*c_neg')

    Sigma = real(Sigma)
    var = diag(Sigma)
    sigma = sqrt.(var)
    rho = Sigma ./ (sigma * sigma')

    return rho, Sigma, var
end

# Original Matlab Code from 1:2N
function CFTcorrOrig(p, t; kwargs...)
    ## Pre-allocate arrays and check Data
    np = size(p)[1]
    mp = size(p)[2]
    nt = size(t)[1]

    @argcheck size(p) == size(t) DimensionMismatch

    # Re-scale trading times
    tau = scale(t)
    # Computing minimum time change
    # minumum step size to avoid smoothing
    dtau = diff(filter(!isnan, tau))
    taumin = minimum(filter((x) -> x>0, dtau))
    taumax = 2*pi
    # Sampling Freq.
    N0 = taumax/taumin

    # Optional Cutoff - if not specified we use Nyquist Cutoff
    kwargs = Dict(kwargs)

    if haskey(kwargs, :N)
        k = collect(1:1:kwargs[:N])
    else
        k = collect(1:1:round(2*N0))
    end

    Den = length(k)

    #------------------------------------------------------
    e_pos = zeros(ComplexF64, mp, Den)
    e_neg = zeros(ComplexF64, mp, Den)

    for i in 1:mp
        psii = findall(!isnan, p[:,i])
        P = p[psii, i]
        Time = tau[psii, i]
        DiffP = diff(log.(P))

        e_pos[i,:] = DiffP' * exp.(1im * Time[1:(end-1),:] * k')
        e_neg[i,:] = DiffP' * exp.(-1im * Time[1:(end-1),:] * k')
    end

    Sigma = zeros(ComplexF64, mp, mp)

    Sigma[1, 1] = 1 / (Den) * (sum(e_pos[1,:] .* e_neg[1,:]))
    Sigma[1, 2] = 1 / (Den) * (sum(e_pos[1,:] .* e_neg[2,:]))
    Sigma[2, 1] = Sigma[1, 2]
    Sigma[2, 2] = 1 / (Den) * (sum(e_pos[2,:] .* e_neg[2,:]))
    # Sigma = 0.5 / (2*Den + 1) .* (c_pos*c_pos' + c_neg*c_neg')

    Sigma = real(Sigma)
    var = diag(Sigma)
    sigma = sqrt.(var)
    rho = Sigma ./ (sigma * sigma')

    return rho, Sigma, var
end

mu = [0.01/86400, 0.01/86400]
sigma = [0.1/86400 sqrt(0.1/86400)*0.35*sqrt(0.2/86400);
        sqrt(0.1/86400)*0.35*sqrt(0.2/86400) 0.2/86400]

P = GBM(10000, mu, sigma, seed = 10)
t = reshape([collect(1:1:10000.0); collect(1:1:10000.0)], 10000, 2)

P1 = GBM(10000, mu, sigma)
t1 = reshape([collect(1:1:10000.0); collect(1:1:10000.0)], 10000, 2)

rm1 = sample(2:9999, 4000, replace = false)
rm2 = sample(2:9999, 4000, replace = false)

P1[rm1, 1] .= NaN
t1[rm1, 1] .= NaN
P1[rm2, 2] .= NaN
t1[rm2, 2] .= NaN

j1 = CFTcorrDK(P, t)
j2 = CFTcorrOrig(P, t)

(j1[1] .- j2[1]) ./ j1[1]

j3 = CFTcorrDK(P1, t1)
j4 = CFTcorrOrig(P1, t1)

(j3[1] .- j4[1]) ./ j3[1]
